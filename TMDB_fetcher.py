#! /usr/bin/python
# -*- coding: utf-8 -*-
"""TMDB_fetcher.py script.

This tool allows for walking through a directory tree containing movie files and to query the TMDB movie database
in order to establish a note describing each found movie.
The note will have the same name as the movie file, with .txt extension.
As a default it will be located in the same place as the movie file.
A catalog can be established listing all the found files.

Note : A key must have prealably registered an account at https://www.themoviedb.org/account/signup 
       and requested a key from your account.
       The key must be provided as a parameter.

Copyright Christophe Mineau - www.labellenote.fr
Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License



Usage:
    TMDB_fetcher.py <path> --key=<TMDB_KEY> [--buildCatalog] [--sheet=<>] [--verbose] [--posters]
    TMDB_fetcher.py <path> --cleanup
    TMDB_fetcher.py  (-h | --help)

Options:
   -h --help               Get help.
  --version                Get this program version.
  --key=<key>              Key provided by TMDBapi.com, see http://www.TMDBapi.com/apikey.aspx
  --sheet=<single|individual|both>     individual : creates one description sheet per movie; single : 1 file describing all movies; both : both  [default: individual] 
  --verbose                Prints all informations got from TMDB
  --buildCatalog           Builds a catalog file (MOVIE_CATALOG.TXT) of all movies found in the tree. 
  --movieSheet=<1|2|3>     1 : one description sheet per movie; 2 : one file describing all movies; 3 : both  [default: 1]    
  --posters                Downloads the poster of the film   
  --cleanup                Removes all files generated by this tool.
  
  
Example:
  python TMDB_fetcher.py "E:\Videos" -k=abcdef 
  python TMDB_fetcher.py "D:\" -k=abcdef --buildCatalog --movieSheet=3
  
"""
# TMDB API, see : https://pypi.org/project/tmdbv3api/
# see the json schemas here :  https://developers.themoviedb.org/3/movies/get-movie-details

from tmdbv3api import TMDb  # $ pip install tmdbv3api
TMDB = TMDb()
from tmdbv3api import Movie
MOVIE = Movie()

import json
import argparse
from docopt import docopt  # pip install docopt
import os
import re
import textwrap
import logging
import datetime
import wget # pip install wget


VERSION=1.0
CATALOG = "CATALOGUE_FILMS.TXT"
SHEETS = "FICHES_FILMS.TXT"
LOG_FILE = "TMDB_fetcher.log"
SHEET_SUFFIX = '_tmdb.txt'
POSTER_SUFFIX = '_tmdb'


class dbFile:
    "generic catalog file, class to be inherited"
    SEPARATOR = '-'*40+'\n'
    def __init__(self, f):
        self.filePath = f
        self.fileTxt = ''
        
    def txtFormat(self, mv): 
        "to be overwritten"
        return mv    
        
    def addFilm(self, mv):
        self.fileTxt += self.txtFormat(mv)
        self. nbFilms += 1
    
    def writeFile(self):
        global LOGGER
        global VERSION
        with open(self.filePath, "w", encoding="utf-8") as fh:
            fh.write("Fichier édité le {} par TMDB_fetcher.py version {}.\n".format(datetime.datetime.now(), VERSION))
            fh.write("La base contient à cette date {} films.\n\n".format(self. nbFilms))
            fh.write(self.fileTxt)
            LOGGER.debug("Fichier créé : '{}'".format(self.filePath))
        LOGGER.warn("Consulter le fichier : {}".format(self.filePath))
    
class Catalog(dbFile):
    def __init__(self, f):
        dbFile.__init__(self, f)
        self. nbFilms = 0
        
    def txtFormat(self, mv): 
        "mv is of class Film"
        return "Titre: '{}'    --- Année: '{}'    --- Fiche: {}  --- {}  \n".format(mv.filmName, mv.filmYear, "oui" if mv.tmdbId else "non", mv.filePath)
        
class NoteFile(dbFile):
    def __init__(self, f):
        dbFile.__init__(self, f)
        self. nbFilms = 0
    
    def txtFormat(self, mv):
        "mv is of class Film"
        if mv.tmdbId:
            note = mv.note
        else:
            note = "Chemin : {}\nAucune info sur TMDB.".format(mv.filePath)
        return "{sep}{}\n{sep}\n\n".format(note, sep=dbFile.SEPARATOR)
        
        
        
class Film:
    def __init__(self, f):
        global DEBUG
        global INDIVIDUAL_SHEET
        global LOGGER
        global POSTERS
        self.filePath = f 
        self.fileDir = os.path.dirname(f)
        self.filmName , self.filmYear, self.filmExtension = Film.getFilmNameAndYearFromPath(f)
        self.poster = None  
        TMDBSearchEnd = False
        while not TMDBSearchEnd:
            self.queryTMDB()
            TMDBSearchEnd = True if self.tmdbId else self.proposeAlternative()                
        self.buildNote()
        if INDIVIDUAL_SHEET:
            self.writeNote()
        if POSTERS and self.poster:
            self.downloadPoster()


    @classmethod    
    def isMovie(cls,f):
        filename, file_extension = os.path.splitext(f)
        return file_extension.lower() in {'.avi', '.mp4', '.mpg'}
    
    @classmethod    
    def getFilmNameAndYearFromPath(cls, p):
        global LOGGER
        baseName = os.path.basename(p)
        fileName, fileExtension = os.path.splitext(baseName)
        yearExp = "[\s\.-]*(\d\d\d\d)\s*$"
        m = re.search(yearExp, fileName)
        if m:
            year =  m.group(1)
            filmName = fileName[0:m.start()]
        else:
            year = None
            filmName = fileName
        LOGGER.info("\n\n"+'-'*80+"\n{} ==> Titre='{}' année='{}'".format(p, filmName , year)) 
        return filmName, year, fileExtension 
    
    @classmethod    
    def getYearFromTmdbDate(cls, d):
        return d.split('-')[0]
    
    def queryTMDB(self):
        """Queries TMDB and tries to narrow the list returned by date
        sets tmdbId if found else possibleList"""
        global LOGGER
        self.tmdbId = None
        self.possibleList = []
        
        filmList =  MOVIE.search(self.filmName)
        LOGGER.info("TMDB a retourné {} possibilités : {}".format(len(filmList), [f.title+'-'+f.release_date for f in filmList]))
        # check if in the list something matches with the file Year
        if self.filmYear:
            foundCount = 0
            for f in filmList:
                if Film.getYearFromTmdbDate(f.release_date)==self.filmYear and self.filmName.strip().lower()==f.title.strip().lower():
                    foundCount += 1
                    selectedFilm = f
            if foundCount == 1:  # If only one film with matching year, consider it is it
                LOGGER.info("Le titre et l'année correspondent.")
                self.tmdbId = selectedFilm.id
                self.renameFilm("{} - {}".format(selectedFilm.title, Film.getYearFromTmdbDate(selectedFilm.release_date)))
                return  
            else:
                self.tmdbId = None
        else:
            if len(filmList)==1:
                selectedFilm = filmList[0]
                self.tmdbId = selectedFilm.id
                self.renameFilm("{} - {}".format(selectedFilm.title, Film.getYearFromTmdbDate(selectedFilm.release_date)))
                return
            else:
                self.tmdbId = None
        self.possibleList = filmList  # otherwise returns the list, possibly empty list
             

    def proposeAlternative(self):
        """ In case 0 or several films compete, ask the operator for his choice"""
        global LOGGER
        TMDBSearchEnd = True
        
        def correctAnswer(limit, answer):
            try:
                answer=int(answer)
            except:
                return False
            return True if answer>=0 and answer<=limit else False
        
        if len(self.possibleList)==0:  # No choice from TMDB
            return self.proposeRenaming()
        
        LOGGER.debug("Liste de choix proposée pour le film '{}'".format(self.filmName))
        
        print("Plusieurs possibilités pour le film '{}'\nRenommer le film : \n ".format(self.filmName), end='')
        choice=[ "\t{} : {} - {}".format(indice, f.title, f.release_date) for indice, f in enumerate(self.possibleList)]
        choice.append("\t{} : Autre titre".format(len(choice)))
        choice.append("\t{} : Passer".format(len(choice)))
        for c in choice:
            print(c)
            LOGGER.debug("{}'".format(c))
        satisfyingAnswer = False
        while not satisfyingAnswer:
            print("\tVotre choix ? (0<{}) : ".format(len(choice)-1), end='')
            r = input()
            if correctAnswer(len(choice)-1, r):
                satisfyingAnswer = True
            else:
                LOGGER.debug("Entrée incorrecte '{}'".format(r))                
        LOGGER.info("Choix retenu '{}'".format(r))    
        if int(r)==len(choice)-1:     # Passer
            TMDBSearchEnd = True
            self.tmdbId = None
        elif int(r)==len(choice)-2:  # Autre
            TMDBSearchEnd = self.proposeRenaming(elseChoice=True)
        else:
            TMDBSearchEnd = True  # Choix parmi les films proposés
            selectedFilm = self.possibleList[int(r)]
            self.tmdbId = selectedFilm.id
            self.renameFilm("{} - {}".format(selectedFilm.title, Film.getYearFromTmdbDate(selectedFilm.release_date))) # Align file name with TMDB name
                       
        return TMDBSearchEnd        
        

    def proposeRenaming(self, elseChoice=False):
        """ In case no idea, ask the operator for a renaming"""
        global LOGGER
        satisfyingAnswer = False
        TMDBSearchEnd = True
        
        LOGGER.debug("Renommage proposé pour le film '{}'".format(self.filmName))
        if elseChoice:
            r='o'
        else:
            while not satisfyingAnswer:
                print("La base de donnée TMDB ne connaît pas le film '{}'\nVoulez vous le renommer (O/N) ? : ".format(self.filmName), end='')
                r = input().lower()
                satisfyingAnswer = True if r in ('o', 'n') else False
            
        if r=="o":
            LOGGER.debug("  Nouveau nom :'{}'".format(r))
            satisfyingAnswer = False
            while not satisfyingAnswer:
                print("Proposez un nouveau nom pour le film '{}' :".format(self.filmName))
                print("Conseil: Pour plus de précision, il est possible d'ajouter la date de sortie à la fin du nom, exemple : 'Avatar-2009'.\nNouveau nom : ", end='')
                r = input()
                satisfyingAnswer = True if r else False
            TMDBSearchEnd = False if self.renameFilm(r) else True
        else:
            LOGGER.debug("  PAS de nouveau nom.")
            TMDBSearchEnd = True
            self.tmdbId = None
            
        return TMDBSearchEnd
                
    def renameFilm(self, r):
        global LOGGER
        # sanitization
        r = r.replace('<', ' ')
        r = r.replace('>', ' ')
        r = r.replace(':', ' ')
        r = r.replace('"', ' ')
        r = r.replace('/', ' ')
        r = r.replace('\\', ' ')
        r = r.replace('|', ' ')
        r = r.replace('?', ' ')
        r = r.replace('*', ' ')
        newFilePath = os.path.join(self.fileDir, r + self.filmExtension)
        if newFilePath != self.filePath:
            LOGGER.info("Renommage '{}' => '{}'".format(self.filePath, newFilePath))  
            try:
                os.rename(self.filePath, newFilePath)
            except IOError as e:
                LOGGER.error("Erreur en renommant {}, exception : {}".format(r, e.strerror))
                return False
            self.filePath = newFilePath
            self.filmName , self.filmYear, self.filmExtension = Film.getFilmNameAndYearFromPath(newFilePath) 
        return True    
            
    def buildNote(self):
        global LOGGER
       
        if self.tmdbId:
            details = MOVIE.details(self.tmdbId)
            credits = MOVIE.credits(self.tmdbId)
            actorsList =  [a['name'] for a in credits.cast]
            genreList = [g['name'] for g in details.genres]
            directorList = [d['name'] for d in credits.crew if d['job']=="Director"]
            writersList = [d['name'] for d in credits.crew if d['job']=="Screenplay"]
            music = [d['name'] for d in credits.crew if "Music" in d['job']]
            pays = [p['name'] for p in details.production_countries]
            self.poster = "http://image.tmdb.org/t/p/w400" + details.poster_path
            
            self.note = "Titre : {}\n".format (details.title)
            self.note += "Chemin : {}\n".format (self.filePath)    
            self.note += "Année : {}\n".format (Film.getYearFromTmdbDate(details.release_date))
            self.note += "Acteurs : {}\n".format (actorsList)
            self.note += "Genre : {}\n".format (genreList)
            self.note += "Pays : {}\n".format (pays)
            self.note += "Affiche : {}\n".format (self.poster)
            self.note += "Durée (mn) : {}\n".format (details.runtime)
            self.note += "Metteur en scène : {}\n".format (directorList)
            self.note += "Auteur : {}\n".format (writersList) 
            self.note += "Musique : {}\n".format (music) 
            self.note += "Synopsis : {}".format (textwrap.fill(details.overview,80))
        else:
            self.note = None
        LOGGER.info(self.note)
        
    def writeNote(self):
        global LOGGER
        global SHEET_SUFFIX
        if self.note:
            dirName =  os.path.dirname(self.filePath)
            baseName = os.path.basename(self.filePath)
            fileName, fileExtension = os.path.splitext(baseName)
            noteFileName = os.path.join(dirName, fileName + SHEET_SUFFIX)
            LOGGER.info("Ecriture fiche  : {}".format(noteFileName))  
            with open(noteFileName, "w", encoding="utf-8") as f:
                    f.write(self.note)
        else:
            LOGGER.warn("Aucune info pour le film : {}".format(self.filmName))  
       
    def downloadPoster(self):
        global POSTER_SUFFIX
        global LOGGER
        dirName =  os.path.dirname(self.filePath)
        baseName = os.path.basename(self.filePath)
        fileName, fileExt = os.path.splitext(baseName)
        posterName, posterExt = os.path.splitext(self.poster)
        posterPath = os.path.join(dirName, fileName + POSTER_SUFFIX + posterExt)
        try:
            downloadName = wget.download(self.poster, out=posterPath)
            LOGGER.info("Affiche téléchargée : {}".format(posterPath))
        except:
            LOGGER.warn("Echec de téléchargement: {}".format(self.poster)) 
            return
                

    
class MovieDB:
    " Small DB holding the found informations and able to make catalogus"
    def __init__(self, path): 
        global MOVIE_CATALOG
        global BUILD_CATALOG
        global MOVIE_SHEETS
        global SINGLE_SHEET
        self.rootPath = path
        self.movieDB = []
        self.movieCatalog = Catalog(os.path.join(self.rootPath, MOVIE_CATALOG)) if BUILD_CATALOG else None
        self.noteFile = NoteFile(os.path.join(self.rootPath, MOVIE_SHEETS)) if SINGLE_SHEET else None
        
    def lookForMovies(self):
        for (dirpath, dirnames, filenames) in os.walk(self.rootPath):
            for filename in filenames:
                if Film.isMovie(filename): 
                    self.movieDB.append(Film(os.path.join(dirpath, filename)))
                    
    def doBuildMovieNotesFile(self):
        "makes a single file gathering all the notes for the found films, instead of plenty of small notes here and there"
        for mv in self.movieDB:
            self.noteFile.addFilm(mv)
        self.noteFile.writeFile()
    
    def doBuildCatalog(self):
        "makes a catalog listing the found files"
        for mv in self.movieDB:
            self.movieCatalog.addFilm(mv)
        self.movieCatalog.writeFile()

def doCleanup(p):
    "Removes all the files generated by this tool"   
    global LOGGER
    global SHEET_SUFFIX
    global POSTER_SUFFIX
    global CATALOG
    global SHEETS
    
    def isNote(f):
        return True if SHEET_SUFFIX in f else False
    
    def isCatalogue(f):
        return True if CATALOG in f else False
    
    def isSingleNote(f):
        return True if SHEETS in f else False
    
    def isPoster(f):
        return True if POSTER_SUFFIX in f else False
    
    for (dirpath, dirnames, filenames) in os.walk(p):
        for filename in filenames:
            if isNote(filename) or isCatalogue(filename) or isSingleNote(filename) or isPoster(filename): 
                filepath = os.path.join(dirpath, filename)
                os.remove(filepath)
                LOGGER.debug("Fichier supprimé : '{}'".format(filepath))

if __name__ == "__main__":

    # __doc__ contains the module docstring
    # docopt lib manages the arguments and the manager is built upon the help string provided (posix style). Here we give the docstring
    

    
    ## Manage arguments ## 
    arguments = docopt(__doc__, version=VERSION)
    #print(arguments)
    try:
        DIRPATH = arguments['<path>']
        sheet = arguments['--sheet']
        if sheet not in ('single','individual','both'):
            raise 
        SINGLE_SHEET = True if sheet=='single' or sheet=='both' else False
        INDIVIDUAL_SHEET = True if sheet=='individual' or sheet=='both' else False
        VERBOSE = True if arguments['--verbose'] else False
        BUILD_CATALOG = True if arguments['--buildCatalog'] else False
        KEY = arguments['--key']
        CLEANUP = True if arguments['--cleanup'] else False
        POSTERS = True if arguments['--posters'] else False
    except:
        print("ERROR: Incorrect parameters, use --help.")
        exit(1)
        
    #exit(0)
        
    ## Logging Capacity ##
    # create logger
    LOGGER = logging.getLogger("TMDB_fetcher.py")
    LOGGER.propagate = False
    LOGGER.setLevel(logging.DEBUG)
    # create console handler and set level 
    ch = logging.StreamHandler()
    if VERBOSE:
        ch.setLevel(logging.INFO)
    else:
        ch.setLevel(logging.WARN)
    # create a file handler and set level 
    fh = logging.FileHandler(os.path.join(DIRPATH, LOG_FILE), encoding ="utf-8", mode='w')
    fh.setLevel(logging.DEBUG)
    # create formatter
    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    # add formatter to handlers
    ch.setFormatter(formatter)
    fh.setFormatter(formatter)
    # add handlers to logger
    LOGGER.addHandler(ch)
    LOGGER.addHandler(fh)
    # start of logging session
    LOGGER.info("{} - TMDB_fetcher.py - {} - by C.Mineau".format(datetime.datetime.now(), VERSION))

    if CLEANUP:
        doCleanup(DIRPATH)
    else:
    
        TMDB.api_key = KEY
        TMDB.language = 'fr'
        TMDB.debug = False
        

        MOVIE_CATALOG = os.path.join(DIRPATH, CATALOG)
        MOVIE_SHEETS = os.path.join(DIRPATH, SHEETS)
        
        
        movieDB = MovieDB(DIRPATH)
        movieDB.lookForMovies()
        
        if BUILD_CATALOG:
            movieDB.doBuildCatalog()
            
        if SINGLE_SHEET:
            movieDB.doBuildMovieNotesFile()
    
    LOGGER.info("{} - Fin de traitement TMDB_fetcher.py ".format(datetime.datetime.now()))
    
    
